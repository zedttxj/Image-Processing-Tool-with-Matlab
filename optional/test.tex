
%-------Packages---------
\documentclass[11pt]{amsart}
\usepackage{amsmath}
\usepackage{latexsym,amssymb,verbatim}
%\usepackage{xypic}
\usepackage{shuffle} % Used for the shuffle product symbol.
\usepackage{caption}
\usepackage{graphicx}
\usepackage{amsfonts}
\usepackage[all,arc]{xy}
\usepackage{enumerate}
\usepackage{mathrsfs}
\usepackage{setspace}
\usepackage{color}
\usepackage{xcolor}
\usepackage{color, colortbl}
\usepackage{pdfpages}
\usepackage{tikz}
\usetikzlibrary{arrows}
\usepackage{enumitem}
\usepackage{stmaryrd}
\usepackage{extarrows}
\usepackage{array}
\usepackage{young}
\usepackage{youngtab}
\usepackage{ytableau}
\definecolor{mygreen}{rgb}{0,.4,0}
\definecolor{myblue}{rgb}{0,0,.5}
\usepackage[bookmarks=true,colorlinks,linkcolor=myblue,citecolor=mygreen]{hyperref}
\usepackage{bbding}
\usepackage[margin=1in]{geometry}
\usetikzlibrary{calc,decorations.pathreplacing,calligraphy,matrix}
\usepackage{hyperref}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\tikzset{Dotted/.style={% https://tex.stackexchange.com/a/52856/194703
		line width=\pgfkeysvalueof{/tikz/Young/dot size},
		dash pattern=on 0.001\pgflinewidth off #1,line cap=round,
		shorten <=#1},Dotted/.default=3pt,
	vdots/.style={draw=none,path picture={
			\draw let \p1=(path picture bounding box.north),
			\p2=(path picture bounding box.south) in
			[Dotted={(\y1-\y2)/4}]
			(\p1) -- (\p2);
	}},
	cdots/.style={draw=none,path picture={
			\draw let \p1=(path picture bounding box.east),
			\p2=(path picture bounding box.west) in
			[Dotted={(\x1-\x2)/4}]
			(\p2) -- (\p1);
	}},
	Young tableau/.style={matrix of math nodes,nodes in empty cells,
		nodes={draw,minimum size=\pgfkeysvalueof{/tikz/Young/cell size},inner sep=0.5pt},
		column sep=-\pgflinewidth,row sep=-\pgflinewidth},
	Young/.cd,cell size/.initial=1.75em,
	dot size/.initial=1.2pt
}

%------------------Theorems

%regular setup
%\setlength{\textheight}{225mm} 
%\setlength{\textwidth}{165mm} 
%\setlength{\oddsidemargin}{-0.2cm}
%\setlength{\evensidemargin}{-0.2cm}
%\linespread{1.1}

%small setup
\setlength{\textheight}{225mm} 
\setlength{\topmargin}{0.16cm}
\setlength{\textwidth}{165mm} 
\setlength{\oddsidemargin}{-0.2cm}
\setlength{\evensidemargin}{-0.2cm}



%very small 
%\setlength{\textheight}{235mm} 
%\setlength{\oddsidemargin}{-0.2cm}
%\setlength{\evensidemargin}{-0.2cm}
%\textwidth165mm
%\textheight23.4cm
%%%%%%%%%%%%%%%5%\hoffset-24mm
%\voffset-7mm

%\def\checkmark{\tikz\fill[scale=0.4](0,.35) -- (.25,0) -- (1,.7) -- (.25,.15) -- cycle;} 
%\checkmark 
\setlength{\parindent}{0pt}
\newtheorem{theorem}{Theorem}[section]
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{corollary}[theorem]{Corollary}
%\theoremstyle{definition}
\newtheorem{definition}[theorem]{Definition}
\newtheorem{definitions}[theorem]{Definitions}
\newtheorem{example}[theorem]{Example}
\newtheorem{problem}[theorem]{Problem}
\theoremstyle{remark}
\newtheorem{remark}[theorem]{Remark}
\newtheorem{exercise}[theorem]{Exercise}
\newtheorem{remarks}[theorem]{Remarks}
\newtheorem{question}[theorem]{Question}
\newtheorem{claim}[theorem]{\bf\hspace*{-1ex}}
\renewenvironment{proof}{{\noindent\bf Proof.}}{\hfill $\Box$\par\vskip3mm}

\newcommand{\Ker}{{\rm Ker}\,}
\newcommand{\Coker}{{\rm Coker}\,}
\newcommand{\im}{{\rm Im}\,}
\newcommand{\coim}{{\rm Coim}\,}
\newcommand{\Hom}{{\rm Hom}}
\newcommand{\End}{{\rm End}}
\newcommand{\Ext}{{\rm Ext}}
\newcommand{\Mor}{{\rm Mor}\,}
\newcommand{\Aut}{{\rm Aut}\,}

\newcommand\Symm{\mathfrak{S}} % Symmetric group.
\newcommand\Lieg{\mathfrak{g}}
\newcommand\Liep{\mathfrak{p}}
\newcommand\ooo{\mathfrak{o}}
\newcommand\mmm{\mathfrak{m}}

\newcommand\kk{\mathbf{k}}
\newcommand\rr{\mathbf{r}}
\newcommand\kkk{\mathbf{K}}

\newcommand\starstar{{\boxplus}}

\newcommand\ii{{\mathbf{i}}}
\newcommand\jj{{\mathbf{j}}}
\newcommand\xx{{\mathbf{x}}}
\newcommand\XX{{\mathbf{X}}}
\newcommand\yy{{\mathbf{y}}}
\newcommand\YY{{\mathbf{Y}}}
\newcommand\zz{{\mathbf{z}}}
\newcommand\RRR{{\mathbf{R}}}
\newcommand\pt{\mathbf{pt}}

\newcommand\aaa{{\mathfrak{A}}}
\newcommand\sss{{\mathfrak{s}}}
\newcommand\bbb{{\mathfrak{B}}}
\newcommand\ccc{{\mathfrak{C}}}
\newcommand\ddd{{\mathfrak{D}}}
\newcommand\eee{{\mathfrak{E}}}
\newcommand\ppp{{\mathfrak{p}}}
\newcommand\PBT{{\mathcal{PBT}}}
\newcommand\AAA{{\mathcal{A}}}
\newcommand\BBB{{\mathcal{B}}}
\newcommand\CCC{{\mathcal{C}}}
\newcommand\FFF{{\mathcal{F}}}
\newcommand\GGG{{\mathcal{G}}}
\newcommand\HHH{{\mathcal{H}}}
\newcommand\JJJ{{\mathcal{J}}}
\newcommand\III{{\mathcal{I}}}
\newcommand\LLL{\mathcal{L}}
\newcommand\YYY{\mathcal{YD}}
\newcommand\DDD{\mathcal{BYD}}
\newcommand\MMM{{\mathcal{M}}}
\newcommand\PPP{{\mathcal{P}}}
\newcommand\BB{{\mathcal{B}}}
\newcommand\SSS{{\mathcal{S}}}
\newcommand\TTT{{\mathcal{T}}}

\newcommand\Aa{{\mathscr{A}}}
\newcommand\Bb{{\mathscr{B}}}
\newcommand\Cc{{\mathscr{C}}}
\newcommand\Pp{{\mathscr{P}}}
\newcommand\Qq{{\mathscr{Q}}}
\newcommand\Ee{{\mathscr{E}}}
\newcommand\Uu{{\mathscr{U}}}
\newcommand\Gg{{\mathscr{G}}}
\newcommand\Hh{{\mathscr{H}}}
\newcommand\Jj{{\mathscr{J}}}
\newcommand\Kk{{\mathscr{K}}}
\newcommand\Mm{{\mathscr{M}}}
\newcommand\Nn{{\mathscr{N}}}

\newcommand\ZZ{{\mathbb Z}}
\newcommand\FF{{\mathbb F}}
\newcommand\QQ{{\mathbb Q}}
\newcommand\NN{{\mathbb N}}
\newcommand\CC{{\mathbb C}}
\newcommand\RR{{\mathbb R}}
\newcommand\KK{{\mathbb K}}
\newcommand\LL{{\mathbb L}}
\newcommand\Proj{{\mathbb P}}
\providecommand{\tightlist}{%
  \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}}


%-----------------------------------------------------------

%--------Theorem Environments--------
%theoremstyle{plain} --- default
\newtheorem{thm}{Theorem}
\newtheorem{cor}[thm]{Corollary}
\newtheorem{prop}[thm]{Proposition}
\newtheorem{lem}[thm]{Lemma}
\newtheorem{conj}[thm]{Conjecture}
\newtheorem{quest}[thm]{Question}

\theoremstyle{definition}
\newtheorem{defn}[thm]{Definition}
\newtheorem{defns}[thm]{Definitions}
\newtheorem{con}[thm]{Construction}
\newtheorem{exmp}[thm]{Example}
\newtheorem{exmps}[thm]{Examples}
\newtheorem{notn}[thm]{Notation}
\newtheorem{notns}[thm]{Notations}
\newtheorem{addm}[thm]{Addendum}
\newtheorem{exer}[thm]{Exercise}

\theoremstyle{remark}
\newtheorem{rem}[thm]{Remark}
\newtheorem{rems}[thm]{Remarks}
\newtheorem{warn}[thm]{Warning}
\newtheorem{sch}[thm]{Scholium}

\setcounter{MaxMatrixCols}{20}



\newcommand\qtbin[2]{\left[\begin{matrix} #1 \\ #2 \end{matrix} \right]}
\newcommand\qbin[3]{\left[\begin{matrix} #1 \\ #2 \end{matrix} \right]_{#3}}
\newcommand\shuf[2]{{#1}\, \shuffle \,{#2}}

\newcommand\ncps[2]{{#1}\left<\left< {#2} \right>\right>}
\newcommand\powser[2]{{#1}\left[\left[ {#2} \right]\right]}

\makeatletter
\let\c@equation\c@thm
\makeatother
\numberwithin{equation}{section}

\bibliographystyle{plain}


\newcommand{\defqed}{\hspace*{\fill} $\square$}
\DeclareMathOperator{\lcm}{lcm}
% define the title

\title{Partition Differential Equations and Some Combinatorial Algebraic Structures}
\author{ADNAN Hashim ABDULWAHID}
\date{}

\begin{document}
	
	
	
	\begin{abstract}
		\noindent 
		I will do the abstract later.
		
	\end{abstract}
	
	\thanks{2020 \textit{Mathematics Subject Classifications}.  05E05, 05E40, 	05E16,  05E15, 16T15 }%, 20N99, 05E10} 
%Primary 16W30; Secondary 16S90, 16Lxx, 16Nxx, 18E40}
%\thanks{$^*$}
\date{}
\keywords{partitions, derivative, integral, symmetric functions, coalgebra, Stirling}

\maketitle



% generates the title



\noindent

\section{\textbf{Introduction and Preliminaries}}\label{intro.sec} 








\vspace{1cm}



\begin{theorem} \label{thm.dial.14}\textbf{}
	\begin{enumerate}[label=(\roman*)]
		\item The triple $(\Lambda, \eta, u$) is a commutative $\kk$-algebra, where the multiplication is the map	
		$$\Lambda \otimes \Lambda  \overset{\eta}{\longrightarrow} \Lambda, \,\, m_{\mu} \otimes m_{\nu} \mapsto m_{\mu \boxplus \nu},$$ 
		and the unit is the inclusion map $$\kk = \Lambda_0 \overset{u}{\longrightarrow} \Lambda.$$
		\item The triple $(\Lambda, \Theta, \epsilon$) is a $\kk$-coalgebra, where the comultiplication is the map	
		$$\Lambda  \overset{\Theta}{\longrightarrow} \Lambda \otimes \Lambda, \,\, m_{\lambda} \mapsto \sum\limits_{\substack{ (\mu, \nu) \in Par \times Par:\\ \mu \boxplus \nu = \lambda} } m_\mu \otimes m_\nu, $$ 
		and the  counit is the $\kk$-linear map $$\Lambda \overset{\epsilon}{\longrightarrow} \Lambda_0=\kk$$ with $\epsilon|_{\Lambda_0 = \kk} = id_{\kk}$  and  $\epsilon|_{I=\bigoplus_{n > 0} \Lambda_n} = 0$.  
	\end{enumerate}
\end{theorem}


\begin{definition}
	content...
\end{definition}





%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%









%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\vspace{1cm}








\begin{remark}
If $d=x_0=0$ and $M=1$, then $M_1=0$ and $y=f_\lambda(x)= \sum_{i=1}^{k}  m_i x^{i}$.
\end{remark}


Let 
\begin{align*}
y^{(d)}	& \,\, = M f_\lambda(x)= M \sum_{i=1}^{k}  m_i x^{i},
\end{align*}	
\begin{equation*}
(*)   \,\,\, . \,\,\, . \,\,\, . \,\,\, . \,\,\, . \,\,\, . \,\,\, . \,\,\,
\begin{cases}
	y^{(d-1)}(x_0)	& \,\, = M_{d-1} \\
	y^{(d-2)}(x_0)	& \,\, =  M_{d-2}\\
	\quad \quad .	& \quad \quad . \\
	\quad \quad .	& \quad \quad . \\
	\quad \quad .	& \quad \quad . \\
	y^{(1)}(x_0)	& \,\, =  M_1\\
	y^{(0)}(x_0)	& \,\, = M_0 
\end{cases}       
\end{equation*} be  a  $(\lambda,(*))$-partition differential equation.
We have 
\begin{align*}
y^{(d-1)}	& \,\, =  \int M \sum_{i=1}^{k}  m_i x^{i} dx\\
& \,\, = M \int  \sum_{i=1}^{k}  m_i x^{i} dx\\
& \,\, = M  \sum_{i=1}^{k}  m_i \int x^{i} dx\\
& \,\, = M  \sum_{i=1}^{k}  m_i   \frac{x^{i+1}}{i+1} + C_{d-1}\\
& \,\, = M   \sum_{i=1}^{k}  m_i   \frac{x^{i+1}}{(i+1)!/i!} + C_{d-1}\\
\end{align*}	

\begin{align*}
y^{(d-2)}	& \,\, =  \int y^{(d-1)} dx\\
& \,\, = M  \int \sum_{i=1}^{k}  m_i   \frac{x^{i+1}}{(i+1)!/i!} dx + \int C_{d-1} dx\\
& \,\, = M   \sum_{i=1}^{k}    \frac{m_i}{(i+1)!/i!} \int x^{i+1} dx + \int C_{d-1} dx\\
& \,\, = M   \sum_{i=1}^{k}  m_i   \frac{x^{i+2}}{(i+2)(i+1)} + C_{d-1} x+ C_{d-2}\\
& \,\, = M   \sum_{i=1}^{k}  m_i   \frac{x^{i+2}}{(i+2)!/i!} + C_{d-1}x+C_{d-2}\\
\end{align*}	


\begin{align*}
y^{(d-3)}	& \,\, =  \int y^{(d-2)} dx\\
& \,\, = M   \int  \sum_{i=1}^{k}  m_i   \frac{x^{i+2}}{(i+2)!/i!} dx + \int C_{d-1} x dx + \int C_{d-2} dx\\
& \,\, = M  \sum_{i=1}^{k}    \frac{m_i}{(i+2)!/i!} \int x^{i+1} dx + \int C_{d-1} x dx + \int C_{d-2} dx\\
& \,\, = M   \sum_{i=1}^{k}  m_i   \frac{x^{i+3}}{(i+3)(i+2)(i+1)} + C_{d-1} \frac{x^2}{2!} + C_{d-2}x + C_{d-3}\\
& \,\, = M   \sum_{i=1}^{k}  m_i   \frac{x^{i+3}}{(i+3)!/i!} + C_{d-1} \frac{x^2}{2!} + C_{d-2}\frac{x}{1!} + C_{d-3}\\
\end{align*}	


\begin{align*}
y^{(1)}	& \,\, =  \int y^{(2)} dx\\
& \,\, = M  \int  (\sum_{i=1}^{k}  m_i   \frac{x^{i+d-2}}{(i+d-2)!/i!} +  C_{d-1} \frac{x^{d-3}}{(d-3)!}+C_{d-2} \frac{x^{d-4}}{(d-4)!} + \cdots + C_3 \frac{x}{1!}+ C_2) dx\\
& \,\, = M   \sum_{i=1}^{k}   \int  m_i  \frac{x^{i+d-2}}{(i+d-2)!/i!} dx + \int C_{d-1} \frac{x^{d-3}}{(d-3)!} dx + \int C_{d-2} \frac{x^{d-4}}{(d-4)!} dx \\
& \quad \quad + \cdots + \int C_3 \frac{x}{1!} dx + \int C_2 dx\\
& \,\, = M   \sum_{i=1}^{k}    m_i  \frac{x^{i+d-1}}{(i+d-1)!/i!}  +  C_{d-1} \frac{x^{d-2}}{(d-2)!}  +  C_{d-2} \frac{x^{d-3}}{(d-3)!} + \cdots +  C_3 \frac{x^2}{2!}  +  C_2 \frac{x}{1!} +C_1\\
\end{align*}	

\begin{align*}
y^{(0)}	& \,\, =  \int y^{(1)} dx\\
& \,\, = \int( M    \sum_{i=1}^{k}    m_i  \frac{x^{i+d-1}}{(i+d-1)!/i!}  +  C_{d-1} \frac{x^{d-2}}{(d-2)!}  +  C_{d-2} \frac{x^{d-3}}{(d-3)!} + \cdots +  C_3 \frac{x^2}{2!}  +  C_2 \frac{x}{1!} +C_1) dx\\
& \,\, =  M    \sum_{i=1}^{k}    m_i  \frac{x^{i+d}}{(i+d)!/i!}  +  C_{d-1} \frac{x^{d-1}}{(d-1)!}  +  C_{d-2} \frac{x^{d-2}}{(d-2)!} + \cdots +  C_3 \frac{x^3}{3!}  +  C_2 \frac{x^2}{2!} +  C_1 \frac{x}{1!} +C_0`\\
\end{align*}	


Applying the initial conditions, we have 

\begin{equation} \label{IVC.111}
\begin{aligned}
	y^{(0)}	& \,\, =  \sum_{i=1}^{k}  \frac{M m_i}{(i+d)!/i!} x^{i+d} + \frac{M_{d-1} }{(d-1)!} x^{d-1}  +  \frac{M_{d-2} }{(d-2)!} x^{d-2} + \cdots +  \frac{M_{2}}{2!} x^2  +   \frac{M_{1}}{1!} x + M_0\\
	& \,\, =  \sum_{i=1}^{k} \frac{i! M m_i}{(i+d)!} x^{i+d} + \frac{M_{d-1} }{(d-1)!} x^{d-1}  +  \frac{M_{d-2} }{(d-2)!} x^{d-2} + \cdots +  \frac{M_{2}}{2!} x^2  +   \frac{M_{1}}{1!} x + M_0.
\end{aligned}	
\end{equation}



\begin{align}\label{sequence112}
\int^{\!^{(d)}}_{\!_{(*)}} (\lambda) 
&=\left\langle1^{ \frac{M_{1} }{1!}  },2^{  \frac{M_{2} }{2!} } ,\dots,(d-1)^{\frac{M_{d-1} }{(d-1)!} }, d^{0}, (d+1)^{\frac{1! M m_1}{(1+d)!}},   \dots, (k+d)^{\frac{k! M m_k}{(k+d)!} } \right\rangle.
\end{align}	

\begin{theorem}\label{thm.p.d.e.1}
Let $\lambda=\langle1^{m_1},2^{m_2},\dots,k^{m_k}\rangle$ be a partition, and let 
\begin{align}
	y^{(d)}	& \,\, =  M f_\lambda(x)= M \sum_{i=1}^{k}  m_i x^{i},
\end{align}	
be a $(\lambda,(*))$-partition differential equation subject to the initial conditions
\begin{equation*}
	(*)   \,\,\, . \,\,\, . \,\,\, . \,\,\, . \,\,\, . \,\,\, . \,\,\, . \,\,\,
	\begin{cases}
		y^{(d-1)}(x_0)	& \,\, = M_{d-1} \\
		y^{(d-2)}(x_0)	& \,\, =  M_{d-2}\\
		\quad \quad .	& \quad \quad . \\
		\quad \quad .	& \quad \quad . \\
		\quad \quad .	& \quad \quad . \\
		y^{(1)}(x_0)	& \,\, =  M_1\\
		y^{(0)}(x_0)	& \,\, = M_0 
	\end{cases}       
\end{equation*}
Then 
\begin{enumerate}[label=(\roman*)]
	\item We have 
	\begin{equation*}	\begin{aligned}\label{sequence11113}
			\left( \int^{\!^{(d)}}_{\!_{(*)}} (\lambda) \right)^{\!^{(1)}}
			&=	 \int^{\!^{(d-1)}}_{\!_{(*)}} (\lambda) \\
		\end{aligned}	
	\end{equation*} 
	\item In general, we have 
	
	\begin{equation}
		\begin{aligned}\label{sequence11114}
			\left( \int^{\!^{(d)}}_{\!_{(*)}} (\lambda) \right)^{\!^{(t)}}
			&= \int^{\!^{(d-t)}}_{\!_{(*)}} (\lambda)\\
		\end{aligned}	
	\end{equation} 
	for all $1 \leq t \leq d$.
\end{enumerate}
\end{theorem}
\begin{proof}
We prove part (ii) (part (i) is a particular of part (ii)). 	Using (\ref{IVC.111}) , we have 
\begin{equation} \label{IVC.112}
	\begin{aligned}
		\frac{d^t}{dx^t} \,\, y^{(0)} & \,\, = 	\frac{d^t}{dx^t} \,\,( \sum_{i=1}^{k} \frac{i! M m_i}{(i+d)!} x^{i+d} + \frac{M_{d-1} }{(d-1)!} x^{d-1}  +  \frac{M_{d-2} }{(d-2)!} x^{d-2} + \cdots +  \frac{M_{2}}{2!} x^2  +   \frac{M_{1}}{1!} x + M_0)\\
		& \,\, =  \sum_{i=1}^{k} \frac{i! M m_i}{(i+d-t)!} x^{i+d-t} + \frac{M_{d-1} }{(d-t-1)!} x^{d-t-1}  +  %\frac{M_{d-2} }{(d-t-2)!} x^{d-t-2}		 + 
		\cdots +  \frac{M_{t+2}}{2!} x^2  +   \frac{M_{t+1}}{1!} x + M_t\\
		& \,\, =  \sum_{i=1}^{k} \frac{i! M m_i}{(i+d-t)!} x^{i+d-t} + \frac{M_{d-1} }{(d-(t+1))!} x^{d-(t+1)} +  %\frac{M_{d-2} }{(d-t-2)!} x^{d-t-2}		 + 
		\cdots +  \frac{M_{t+2}}{2!} x^2  +   \frac{M_{t+1}}{1!} x + M_t\\
		& \,\, =  y^{(t)}\\
	\end{aligned}	
\end{equation}
which is the solution of the $(\lambda,(*))$-partition differential equation 
\begin{align}
	z^{(d-t)} 	& \,\, =  M f_\lambda(x)= M \sum_{i=1}^{k}  m_i x^{i},
\end{align}	
satisfying the initial conditions
\begin{equation*}
	(*)   \,\,\, . \,\,\, . \,\,\, . \,\,\, . \,\,\, . \,\,\, . \,\,\, . \,\,\,
	\begin{cases}
		z^{(d-t-1)}(x_0)	& \,\, = M_{d-1} \\
		z^{(d-t-2)}(x_0)	& \,\, =  M_{d-2}\\
		\quad \quad .	& \quad \quad . \\
		\quad \quad .	& \quad \quad . \\
		\quad \quad .	& \quad \quad . \\
		z^{(1)}(x_0)	& \,\, =  M_{t+1}\\
		z^{(0)}(x_0)	& \,\, = M_t 
	\end{cases}       
\end{equation*}
for $\lambda=\langle1^{m_1},2^{m_2},\dots,k^{m_k}\rangle$, where  $z^{(0)}=y^{(t)}, \, z^{(1)}=y^{(t+1)}, \, \cdots, \, z^{(d-t)}=y^{(d)}$.
Thus,  
\begin{equation}
	\begin{aligned}\label{sequence11114.2}
		\left( \int^{\!^{(d)}}_{\!_{(*)}} (\lambda) \right)^{\!^{(t)}}
		&= \int^{\!^{(d-t)}}_{\!_{(*)}} (\lambda).\\
	\end{aligned}	
\end{equation} 
\end{proof}





%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%



\section{FUNCTIONS-CODES.pdf}\label{functions-codes.pdf}

\subsection{BP(A)}\label{bpa}

\begin{itemize}
\item
  Input:

  \begin{itemize}
  \tightlist
  \item
    Binary matrix: 2D
  \end{itemize}
\item
  Output:

  \begin{itemize}
  \tightlist
  \item
    Partition (contains the original size of the binary matrix): 1D
  \end{itemize}
\item
  Explanation: The function BP(A) processes a binary matrix by sorting
  each row and each column, counting the number of ones in each row, and
  then storing the count in a partition vector. The partition vector
  represents the number of ones in each row. An alternative approach is
  to count the number of ones in each row first, and then sort them in
  descending order. Both approaches produce the same result.
\item
  Example code:

\begin{verbatim}
data = [
  1 1 1 0;
  0 1 0 1;
  0 1 0 0
];
disp(ImageProcessor.BP(data));
\end{verbatim}
\item
  Run the code:

\begin{verbatim}
>> 
   3     4     3     2     1
\end{verbatim}
\item
  To visualize the sorting process: Here, the first value (\texttt{3})
  stands for the height of the original matrix and the second value
  (\texttt{4}) stands for the width of the original matrix. Followed by
  that is the partition \texttt{{[}3\ 2\ 1{]}}. You can check the sorted
  \texttt{data} matrix with
  \texttt{disp(ImageProcessor.customSorting(data,"rc",{[}1\ 0{]}));}
  though the actual code of this function is different.

  \begin{itemize}
  \item
    Sorted Matrix Output:

\begin{verbatim}
>> 
   1     1     1     0
   1     1     0     0
   1     0     0     0
\end{verbatim}
  \end{itemize}
\end{itemize}

\subsection{PC(lambda, G, order)}\label{pclambda-g-order}

\begin{itemize}
\item
  \textbf{Explanation:}\\
  Think of this function as a derivation of \texttt{BP(A)}. The
  parameters \texttt{lambda} and \texttt{order} are used to construct
  the \texttt{data} matrix (whose structure is unknown initially). Then,
  we extract the colors from \texttt{data} based on the provided
  \texttt{G}. Finally, we sort and count, similar to \texttt{BP(A)}.
\item
  \textbf{Input:}

  \begin{itemize}
  \tightlist
  \item
    \texttt{lambda} (1D): Contains the lengths of each row of the matrix
    to be constructed.
  \item
    \texttt{G} (string or charArray): Specifies the colors to extract
    (e.g., \texttt{"RB"} means extracting only red and blue colors from
    the matrix).
  \item
    \texttt{order} (2D): A matrix that will be replicated to match the
    sizes indicated by \texttt{lambda}.
  \end{itemize}
\item
  \textbf{Output:}\\
  Colored partitions (after extracting and counting the specified
  colors).
\item
  \textbf{Example Code:}
  \texttt{matlab\ \ \ \ \ lambda\ =\ {[}4\ 2\ 1{]};\ \ \ \ \ order\ =\ {[}\ \ \ \ \ \ \ \ \ 3\ 2;\ \ \ \ \ \ \ \ \ 2\ 1;\ \ \ \ \ {]};\ \ \ \ \ disp(ImageProcessor.PC(lambda,\ "RB",\ order));}
\item
  \textbf{Explanation of Example:}

  \begin{itemize}
  \item
    In this example, \texttt{3} stands for blue, \texttt{2} stands for
    green, and \texttt{1} stands for red.\\
  \item
    The \texttt{order} matrix will be replicated according to
    \texttt{lambda} to match the row sizes. Here's how \texttt{order}
    looks after replication:

\begin{verbatim}
3 2 3 2 3 2 3 2...
2 1 2 1 2 1 ...
3 2 3 2 ...
2 1 2 1 2 1 ...
...
\end{verbatim}
  \item
    Now, we cut the rows according to \texttt{lambda} to get the
    following structure:

\begin{verbatim}
3 2 3 2
2 1
3
\end{verbatim}
  \item
    We then extract the red and blue colors since \texttt{G\ =\ "RB"}.
    The extracted values are:

\begin{verbatim}
1 0 1 0
0 1
1
\end{verbatim}
  \item
    Finally, we apply the \texttt{BP(A)} function to get the
    \texttt{coloredPartition}, which is the output without the size of
    the constructed matrix.
  \end{itemize}
\item
  \textbf{Run the Code:}

\begin{verbatim}
>> script
  Warning: lambda shouldn't contain the sizes of the matrix
       2     1     1
\end{verbatim}

  To disable the warning, put `false' in the 4th parameter (after
  \texttt{order}).
\end{itemize}

\subsection{IC1(A, G, order)}\label{ic1a-g-order}

\begin{itemize}
\item
  \textbf{Input:}

  \begin{itemize}
  \tightlist
  \item
    \texttt{A} (2D): A 2D matrix (e.g., an image matrix or any numerical
    matrix).
  \item
    \texttt{G} (string or charArray): Specifies the sorting order of the
    channels (similar to the \texttt{G} parameter in the \texttt{PC}
    function). For example, ``RB'' would mean sorting by Red first, then
    Blue, and ``BR'' would mean sorting by Blue first, then Red.
  \item
    \texttt{order} (2D): A matrix that specifies the color channels.
    It's similar to \texttt{order} in \texttt{PC} function.
  \end{itemize}
\item
  \textbf{Output:}

  \begin{itemize}
  \tightlist
  \item
    \textbf{Filtered Matrices:} The function sorts the matrix \texttt{A}
    based on the channel order specified in \texttt{G} and
    \texttt{order}. It tracks the corresponding entries' positions
    during the sorting process and applies those changes to \texttt{A}.
  \end{itemize}
\item
  \textbf{Explanation:}

  \begin{enumerate}
  \def\labelenumi{\arabic{enumi}.}
  \item
    \textbf{Matrix Sorting by Channel Order:} The \texttt{IC1} function
    takes an input matrix \texttt{A} and sorts it according to the
    channel order specified in \texttt{G} and \texttt{order}. For
    example, if \texttt{G\ =\ "RB"} (meaning
    \texttt{order\ =\ {[}1\ 3\ 2{]}} in \texttt{customSorting}), the
    matrix \texttt{A} will be sorted first by the Red channel, then
    Blue, and lastly by Green. If \texttt{G\ =\ "GR"}(meaning
    \texttt{order\ =\ {[}2\ 1\ 3{]}} in \texttt{customSorting}), it will
    sort by Green, then Red, and then Blue.
  \item
    \textbf{Tracking Indices:} The function keeps track of the indices
    during sorting, so that after sorting, it can correctly reapply the
    changes to the original matrix \texttt{A}.
  \item
    \textbf{Custom Sorting:} To see how the sorting works, you can track
    the row and column indices of \texttt{order} using the
    \texttt{customSorting} function. Here's an example:
  \end{enumerate}

\begin{verbatim}
[data, rows, cols] = ImageProcessor.customSorting(order,"rc",[1 3 2]);
disp(cols + "," + rows);
\end{verbatim}

  \begin{enumerate}
  \def\labelenumi{\arabic{enumi}.}
  \setcounter{enumi}{3}
  \item
    \textbf{Sorted Output Example:}\\
    If the \texttt{order} is \texttt{{[}3\ 2;\ 2\ 1{]}} (2D matrix) and
    the 3rd parameter of the \texttt{customSorting} function is
    \texttt{{[}1\ 3\ 2{]}} (meaning ``R \textless{} B \textless{} G''),
    the output looks like this:

\begin{verbatim}
>> script
   "2,2"    "1,2"
   "1,1"    "2,1"

Sorted order:
     1     2
     3     2
\end{verbatim}

    The \texttt{IC1} function uses these row and column indices to apply
    the sorting to the matrix \texttt{A}.
  \end{enumerate}
\item
  \textbf{Example Code + Explanation:}
  \texttt{matlab\ \ \ \ \ A\ =\ {[}\ \ \ \ \ \ \ \ \ 1\ 2\ 3\ 4;\ \ \ \ \ \ \ \ \ 5\ 6\ 7\ 8;\ \ \ \ \ \ \ \ \ 9\ 10\ 11\ 12;\ \ \ \ \ \ \ \ \ 13\ 14\ 15\ 16;\ \ \ \ \ {]};\ \ \ \ \ order\ =\ {[}\ \ \ \ \ \ \ \ \ 3\ 2;\ \ \ \ \ \ \ \ \ 2\ 1;\ \ \ \ \ {]};\ \ \ \ \ disp(ImageProcessor.IC1(A,\ "RB",\ order));}
\item
  \textbf{Explanation of Example:}\\
  In this example:

  \begin{itemize}
  \tightlist
  \item
    \texttt{3} stands for Blue (B), \texttt{2} stands for Green (G), and
    \texttt{1} stands for Red (R).\\
  \item
    The string \texttt{"RB"} means Red is sorted first, followed by
    Blue, and then Green (not explicitly). So, the sorting process will
    rearrange the elements based on the order.
  \end{itemize}
\item
  \textbf{Run the Code (Output of
  \texttt{disp(ImageProcessor.IC1(A,\ "RB",\ order));}):}
  \texttt{matlab\ \ \ \ \ \textgreater{}\textgreater{}\ script\ \ \ \ \ \ \ \ \ 6\ \ \ \ \ 2\ \ \ \ \ 8\ \ \ \ \ 4\ \ \ \ \ \ \ \ \ 1\ \ \ \ \ 5\ \ \ \ \ 3\ \ \ \ \ 7\ \ \ \ \ \ \ \ \ 14\ \ \ \ 10\ \ \ \ 16\ \ \ \ 12\ \ \ \ \ \ \ \ \ 9\ \ \ \ \ 13\ \ \ \ 11\ \ \ \ 15}
\end{itemize}

\subsection{IC2(image, G, order)}\label{ic2image-g-order}

\begin{itemize}
\item
  Input (3D): an image with red, green, and blue channels
\item
  Output (3D): a filtered image with red, green, and blue channels
  (sorted based on GBR, BGR, etc, and the corresponding entries sorted
  at the same time).
\item
  Example code:

\begin{verbatim}
image = ImageProcessor.readImage('test.png');
order = [
    3 2;
    2 1
];
output = ImageProcessor.IC2(image,"RB",order);
ImageProcessor.showImage(output);
\end{verbatim}
\item
  Run the code:\\
  \includegraphics{images/figure1}\\
\item
  Explanation: Think of this like an enhanced version of \texttt{IC1}
  that works for 3D instead of 2D. It keeps all 3 channels as it
  swapping the values. Let's say the \texttt{image} can be represented
  like this:

\begin{verbatim}
[
  A(1,1,:) A(1,2,:);
  A(2,1,:) A(2,2,:)
];
\end{verbatim}

  If the indices are

\begin{verbatim}
      "2,2"    "1,2"
      "1,1"    "2,1"
\end{verbatim}

  , the function \texttt{IC2} will swap the entries like this:

\begin{verbatim}
[
  A(2,2,:) A(1,2,:);
  A(1,1,:) A(2,1,:)
];
\end{verbatim}
\end{itemize}

\subsection{Bayer1(image, G, order)}\label{bayer1image-g-order}

\begin{itemize}
\item
  Input (3D):

  \begin{itemize}
  \tightlist
  \item
    Image (or binary image, 3D): an image with red, green, and blue
    channels
  \item
    G (string or charArray): similar to \texttt{IC2} and \texttt{IC1}
  \item
    order (2D): similar to \texttt{IC2} and \texttt{IC1}
  \end{itemize}
\item
  Output (2D): filtered matrix
\item
  Explanation: It functions similar to \texttt{IC2} except it will only
  pick one channel to represent on the gray scale. Let's say the
  \texttt{image} can be represented like this:

\begin{verbatim}
[
  A(1,1,1:3) A(1,2,1:3);
  A(2,1,1:3) A(2,2,1:3)
];
\end{verbatim}

  If the indices after sorting are

\begin{verbatim}
      "2,2"    "1,2"
      "1,1"    "2,1"
\end{verbatim}

  and the order sorted (the input order doesn't have to be sorted) in
  the order of ``RB'' is

\begin{verbatim}
   Sorted order:
        1     2
        3     2
\end{verbatim}

  , the function \texttt{IC2} will pick the entries like this:

\begin{verbatim}
[
  A(2,2,1) A(1,2,2);
  A(1,1,3) A(2,1,2)
];
\end{verbatim}
\item
  Example code:

\begin{verbatim}
image = ImageProcessor.readImage('test.png');
order = [
    3 2;
    2 1
];
output = ImageProcessor.Bayer1(image,"RB",order);
ImageProcessor.showImage(output);
\end{verbatim}
\item
  Run the code:\\
  \includegraphics{images/figure2}
\end{itemize}

\subsection{Bayer2(image, G, order)}\label{bayer2image-g-order}

\begin{itemize}
\item
  Input (3D):

  \begin{itemize}
  \tightlist
  \item
    \texttt{image} (3D): an image (or binary image) with red, green, and
    blue channels.
  \item
    \texttt{G} (string or charArray): similar to \texttt{G} in
    \texttt{IC1} and \texttt{IC2} functions.
  \item
    \texttt{order} (2D): similar to \texttt{order} in \texttt{IC1} and
    \texttt{IC2} functions.
  \end{itemize}
\item
  Output (3D): a filtered image with red, green, and blue channel.
\item
  Explanation: similar to \texttt{Bayer1} function but instead of
  producing gray image, it erases other colors and only keep the color
  based on the sorted \texttt{order} (which doesn't have to be sorted as
  input).
\item
  Example: Pick the same example in \texttt{Bayer1} explanation. Instead
  of this output

\begin{verbatim}
[
  A(2,2,1) A(1,2,2);
  A(1,1,3) A(2,1,2)
];
\end{verbatim}

  , it will have this output:

\begin{verbatim}
[
  [A(2,2,1), 0, 0] [0, A(1,2,2), 0];
  [0, 0, A(1,1,3)] [0, A(2,1,2), 0]
];
\end{verbatim}
\item
  Example code:

\begin{verbatim}
order = [
    3 2 2 1;
    2 1 3 3;
    2 3 1 2;
    3 3 1 1
];
image = ImageProcessor.readImage('test.png');
imshow(ImageProcessor.Bayer2(image,"RBG",order));
\end{verbatim}
\item
  Run the code:\\
  \includegraphics{images/figure3}
\end{itemize}

\subsection{Dilation1, Erosion1, Opening1, Closing1 (binaryMatrix1,
binaryMatrix2)}\label{dilation1-erosion1-opening1-closing1-binarymatrix1-binarymatrix2}

\begin{itemize}
\item
  Notes: Some books have different definition of erosion function though
  most of their functions of dilation are commutative. I keep the
  traditional erosion and dilation functions as many book described in
  \texttt{Erosion1} and \texttt{Dilation1}, respectively. Hence, only
  \texttt{Dilation1} is commutative.
\item
  Input:

  \begin{itemize}
  \tightlist
  \item
    binaryMatrix1 (2D or 3D logical): an image with or without red,
    green, and blue channels.
  \item
    binaryMatrix2 (2D or 3D logical): a kernel with or without red,
    green, and blue channels.
  \end{itemize}
\item
  Output:

  \begin{itemize}
  \tightlist
  \item
    Logical 2D (gray) or 3D (rgb) image.
  \end{itemize}
\item
  Explanation. When applying \texttt{Dilation1} and \texttt{Erosion1},
  it will scale the values (logical values) by multiplying the values
  inside the kernel and then find \texttt{max} and \texttt{min},
  respectively. In the case of \texttt{Erosion1}, if any ``0'' is
  encountered in the kernel, it simply ignores that part and does not
  reduce the center value to ``0''. This means that the center pixel
  value will be preserved as long as there are enough ``1''s in the
  region to meet the kernel's size, effectively only removing noise or
  small interruptions in the foreground, adding additional flexibility
  to the function.
\item
  Example: Consider the binary matrices of \texttt{test.png} and
  \texttt{test2.png} (downloaded the images):

\begin{verbatim}
image = ImageProcessor.readImage('test.png');
image2 = ImageProcessor.readImage('test2.png');
image2 = image2(230:235,230:235,:);
image = image > 100;
image2 = image2 > 100;
\end{verbatim}

  \begin{itemize}
  \item
    I used \texttt{imshow(uint8(image)\ *\ 255);} to show the image:\\
    \includegraphics{images/figure4}\\
  \item
    Same thing goes for image2:\\
    \includegraphics{images/figure5}\\
  \item
    I only extract 5x5 grid of the image2 in this example (which
    explains why it appears to be small). Now, I apply
    \texttt{Erosion1}:

\begin{verbatim}
output = ImageProcessor.Erosion1(image,image2);
imshow(output);
\end{verbatim}
  \item
    The output is like this:\\
    \includegraphics{images/figure6}\\
  \item
    I tried with Dilation1, Opening1, and Closing1 respectively:\\
    \includegraphics{images/figure7}\\
    \includegraphics{images/figure8}\\
    \includegraphics{images/figure9}

    \begin{itemize}
    \tightlist
    \item
      It's recommend to have smaller size of \texttt{image2} (ideally 5
      to 35). Swapping the input position results in the same output
      image (only for dilation function):\\
      \includegraphics{images/figure10}\\
      \includegraphics{images/figure11}\\
      \includegraphics{images/figure12}\\
      \includegraphics{images/figure13}
    \end{itemize}
  \item
    An example of applying 2D binary matrices as inputs:

    \begin{itemize}
    \tightlist
    \item
      \texttt{image} =\\
      \includegraphics{images/figure14}\\
    \item
      \texttt{image2} =\\
      \includegraphics{images/figure15}\\
    \item
      \texttt{output} =\\
      \includegraphics{images/figure16}
    \end{itemize}
  \end{itemize}
\end{itemize}

\subsection{Dilation2, Erosion2, Opening2, Closing2 (binaryMatrix1,
binaryMatrix2)}\label{dilation2-erosion2-opening2-closing2-binarymatrix1-binarymatrix2}

\begin{itemize}
\item
  Input:

  \begin{itemize}
  \tightlist
  \item
    binaryMatrix1 (2D or 3D logical): an image with or without red,
    green, and blue channels.
  \item
    binaryMatrix2 (2D or 3D logical): a kernel with or without red,
    green, and blue channels.
  \end{itemize}
\item
  Output:

  \begin{itemize}
  \tightlist
  \item
    Logical 2D (gray) or 3D (rgb) image.
  \end{itemize}
\item
  Explanation. When applying \texttt{Dilation2} and \texttt{Erosion2},
  it will scale the values (colored or gray values) by multiplying the
  values inside the kernel and then find \texttt{max} and \texttt{min},
  respectively.
\item
  Example: Consider the binary matrices of \texttt{test.png} and
  \texttt{test2.png} (downloaded the images):

\begin{verbatim}
image = ImageProcessor.readImage('test.png');
image2 = ImageProcessor.readImage('test2.png');
image2 = image2(230:235,230:235,:);
\end{verbatim}

  \begin{itemize}
  \item
    I used \texttt{imshow(image);} to show the image:\\
    \includegraphics{images/figure17}\\
  \item
    Same thing goes for image2:\\
    \includegraphics{images/figure18}\\
  \item
    I only extract 5x5 grid of the image2 in this example (which
    explains why it appears to be small). Now, I apply
    \texttt{Erosion2}:

\begin{verbatim}
output = ImageProcessor.Erosion2(image,image2);
imshow(output);
\end{verbatim}
  \item
    The output is like this:\\
    \includegraphics{images/figure19}\\
  \item
    I tried with Dilation2, Opening2, and Closing2 respectively:\\
    \includegraphics{images/figure20}\\
    \includegraphics{images/figure21}\\
    \includegraphics{images/figure22}

    \begin{itemize}
    \tightlist
    \item
      If I swap the input position of \texttt{image} and \texttt{image2}
      (\texttt{image} becoming 2nd parameter and \texttt{image2}
      becoming 1st parameter), the program stucks forever due to the
      larger mask being applied in the calculation. It's recommend to
      have smaller size of \texttt{image2} (ideally 5 to 35). Swapping
      the input position doesn't results in the output image being
      flipped up-side-down, left-to-right, or identical image compared
      to the original output. However (fun fact), applying Bayer filter
      seems to make the outputs very identical. In fact, if you flip the
      image up-side-down and left-to-right, it looks almost the same:\\
      \includegraphics{images/figure23}\\
      \includegraphics{images/figure24}\\
    \end{itemize}
  \item
    An example of applying 2D binary matrices as inputs:

    \begin{itemize}
    \tightlist
    \item
      \texttt{image} =\\
      \includegraphics{images/figure25}\\
    \item
      \texttt{image2} =\\
      \includegraphics{images/figure26}\\
    \item
      \texttt{output} =\\
      \includegraphics{images/figure27}
    \end{itemize}
  \end{itemize}
\end{itemize}

\subsection{PPP1(partition1,
partition2)}\label{ppp1partition1-partition2}

\begin{itemize}
\item
  Input:

  \begin{itemize}
  \tightlist
  \item
    Partition 1 (1D): 1D array that contains the coefficients of the
    first polynomial.
  \item
    Partition 2 (1D): similar to partition1.
  \end{itemize}
\item
  Output: 1D array that contains the coefficients of the product of the
  2 polynomials.
\item
  Example code:

\begin{verbatim}
partition1 = [1 2 3 4];
partition2 = [1 3 2 1];
disp(ImageProcessor.PPP1(partition1, partition2));
\end{verbatim}
\item
  Run the code:

\begin{verbatim}
>> 
   1     5    11    18    20    11     4
\end{verbatim}
\item
  Another example code:

\begin{verbatim}
tic;
partition1 = 1:1000000;
partition2 = 1:1000000;
ImageProcessor.PPP1(partition1, partition2);
elapsedTime = toc;
fprintf('Elapsed time: %.6f seconds\n', elapsedTime);
\end{verbatim}
\item
  Run the code:

\begin{verbatim}
>> 
Elapsed time: 25.461543 seconds
\end{verbatim}

  Even without using NTT, the code runs very fast thanks to built-in
  function \texttt{conv}.
\end{itemize}

\subsection{PPP2(partition1,
partition2)}\label{ppp2partition1-partition2}

\begin{itemize}
\item
  Input:

  \begin{itemize}
  \tightlist
  \item
    Partition 1 (1D): sorted 1D array.\\
  \item
    Partition 2 (1D): similar to partition1.\\
  \end{itemize}
\item
  Output:

  \begin{itemize}
  \tightlist
  \item
    A \textbf{sorted 1D array} representing the \textbf{merged}
    partition of \texttt{partition1} and \texttt{partition2} using the
    special operation.
  \end{itemize}
\item
  Explanation of the Operation:

  \begin{itemize}
  \tightlist
  \item
    The constructs a new partition by taking the
    \textbf{multiset union} of the elements from \texttt{partition1} and
    \texttt{partition2}. After merging, the resulting partition is
    \textbf{reordered} in \textbf{weakly decreasing} order.
  \item
    Example:\\
    Given $\boldsymbol{\mu_{ = (3,3,2,1)}}$ and $\boldsymbol{\nu = (4,1,1)}$, the resulting
    partition is: $\boldsymbol{\mu_{ \sqcup \nu = (4,3,3,2,1,1,1)}}$\\
  \end{itemize}
\item
  Example code:

\begin{verbatim}
tic;
partition1 = 50000000:-1:1;
partition2 = 50000000:-1:1;
ImageProcessor.PPP2(partition1,partition2);
elapsedTime = toc;
disp(elapsedTime);
\end{verbatim}
\item
  Run the code:

\begin{verbatim}
>> 
  1.6179
\end{verbatim}
\item
  Another example code:

\begin{verbatim}
partition1 = [6 4 2];
partition2 = [8 5 3 1];
disp(ImageProcessor.PPP2(partition1,partition2));
\end{verbatim}
\item
  Run the code:

\begin{verbatim}
>> 
   8     6     5     4     3     2     1
\end{verbatim}
\end{itemize}

\subsection{EXTRA.DILATION(binaryMatrix1,
binaryMatrix2)}\label{extra.dilationbinarymatrix1-binarymatrix2}

\subsubsection{Input:}\label{input}

\begin{itemize}
\tightlist
\item
  \texttt{binaryMatrix1} (2D or 3D logical): A binary image, with or
  without color channels (RGB).
\item
  \texttt{binaryMatrix2} (2D or 3D logical): A binary structuring
  element (kernel), also with or without color channels.
\end{itemize}

\subsubsection{Output:}\label{output}

\begin{itemize}
\tightlist
\item
  A \textbf{logical} 2D (grayscale) or 3D (RGB) \textbf{image} after
  dilation.
\end{itemize}

\subsubsection{Explanation:}\label{explanation}

Dilation in matrix form is a well-known operation, but before applying
it, we introduce a \textbf{special function} (called
\textbf{MatrixDecomposition}) that transforms the input matrices. This
function modifies both \texttt{A} and \texttt{B}, and apply
\textbf{standard dilation} (as defined in most image processing books)
to the transformed versions.

\subsubsection{MatrixDecomposition
Transformation}\label{matrixdecomposition-transformation}

MatrixDecomposition works as follows (the actual code has different
workflow that works in matrix-based dilation instead of set-based
dilation):

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  \textbf{Extract the coordinates} of all \texttt{1} values in the
  matrix and represent them as ordered pairs \texttt{(x,\ y)}. The first
  coordinate always starts at \texttt{{[}0,0{]}} (zero-based index).

  \begin{itemize}
  \item
    Example: Given the matrix \texttt{A}:

\begin{verbatim}
A = [
  1 1 0 0;
  0 1 0 1
];
\end{verbatim}

    The extracted set of coordinates is
    \texttt{\{{[}0,0{]},\ {[}0,1{]},\ {[}1,1{]},\ {[}1,3{]}\}}.
  \end{itemize}
\item
  \textbf{Compute a new transformed set} satisfying:\\
  $\{(a,b) + (c,d) + \ldots{} \textbar{} (a,b), (c,d), \ldots{} \in A and
  (a,b) \neq (c,d) \neq \ldots\} where \texttt{...}$ can be empty or multiple
  elements of \texttt{A}.
\item
  \textbf{Convert this transformed set back into a matrix}
  representation.
\end{enumerate}

\subsubsection{Comparison Between Set-Based and Matrix-Based
Dilation}\label{comparison-between-set-based-and-matrix-based-dilation}

\paragraph{Set-Based Dilation:}\label{set-based-dilation}

In set notation, the \textbf{dilation of two sets} \texttt{A} and
\texttt{B} is defined as:\\
$A \oplus B = \{ (a,b) + (c,d) \textbar{} (a,b) \in A, (c,d) \in B \}$\\
For every point \texttt{(a,b)} in \texttt{A}, we add all points
\texttt{(c,d)} from \texttt{B} to generate the dilated result.

\paragraph{Matrix-Based Dilation (Efficient
Form):}\label{matrix-based-dilation-efficient-form}

\begin{itemize}
\item
  Instead of iterating over sets, \textbf{matrix dilation} is
  efficiently computed using \textbf{convolution operations} or
  \textbf{max filtering}, where a \textbf{structuring element (kernel)}
  is applied to the binary image.
\item
  \textbf{MatrixDecomposition as Multiple Dilations}: We can think of
  the \textbf{MatrixDecomposition} as a series of dilations for each
  element in the set, where the dilation operator $\oplus$ applies to each
  element in the set $A$. For each element, we consider the set that
  contains the coordinate {[}0,0{]} (the first coordinate) and the
  element itself so that $\oplus$ can be applied. The special function then
  becomes the \textbf{Riemann Dilation sum} of these dilations (like how
  \texttt{+} has \textbf{Riemann sum}, $\oplus$ has \textbf{Riemann Dilation
  sum}). Consider this example:

  \begin{itemize}
  \item
    Example: Generating Subsets Using Dilation

    Consider a set\\
    \textbf{A = \{a, b, c\}}\\
    Normally, we could generate subsets by toggling bits (e.g., using
    binary representation), but instead, we use the \textbf{dilation
    operator} ($\oplus$):

    \begin{itemize}
    \item
      Step 1: Start with the Base Set\\
      ${S0} = \{{[}0,0{]}\}$\\
      This represents the empty set as a starting point.
    \item
      Step 2: Apply Dilation with Each Element

      \begin{itemize}
      \item
        First dilation with element a:\\
        ${{S1} = S0} \oplus \{{[}0,0{]}, a\} = \{{[}0,0{]}, a\}$
      \item
        Second dilation with element b:\\
        ${{S2} = S1} \oplus \{{[}0,0{]}, b\} = \{{[}0,0{]}, a, b, a+b\}$
      \item
        Third dilation with element c:\\
        ${{S3} = S2} \oplus \{{[}0,0{]}, c\} = \{{[}0,0{]}, a, b, c, a+b, a+c,
        b+c, a+b+c\}$
      \end{itemize}
    \item
      \textbf{Resulting Set:}\\
      After three dilations, we have generated all possible subsets of
      A, mimicking how binary toggling would work.
    \end{itemize}
  \end{itemize}
\item
  Effects: This \textbf{reduces computation time} from
  \texttt{O(2\^{}(\textbar{}A\textbar{}))} (where
  \texttt{\textbar{}A\textbar{}} is the length of set A or the number of
  \texttt{1}s of matrix A) in the set-based approach to
  \texttt{$O((max(rows(A))\ x\ max(cols(A)))^4)$} for the
  \texttt{matrixDecomposition} function that transforms the input
  matrices.
\item
  Recommendation:

  \begin{itemize}
  \tightlist
  \item
    Use Matrix-Based Dilation when \texttt{\textbar{}A\textbar{}} is
    large enough (ideally below 676) and \texttt{max(rows(A))} or
    \texttt{max(cols(A))} is not too big.
  \item
    Use Set-Based Dilation (introduced in the below section) when
    \texttt{\textbar{}A\textbar{}} is small enough (ideally below 36).
  \end{itemize}
\item
  Example code:

\begin{verbatim}
tic;
B = ImageProcessor.readImage('test.png');
A = B(200:205,200:205,:) > 160;
B = B(200:225,200:225,:) > 160;
t = ImageProcessor.EXTRA.DILATION(B,A);
imshow(t);
elapsedTime = toc;
disp(elapsedTime);
disp("Size of input image: " + strjoin(arrayfun(@num2str, size(B), 'UniformOutput', false), ' '));
disp("Size of output image: " + strjoin(arrayfun(@num2str, size(t), 'UniformOutput', false), ' '));
\end{verbatim}
\item
  Run the code:
  \includegraphics{images/figure28}\\
\item
  Another example code:

\begin{verbatim}
tic;
B = ImageProcessor.readImage('test.png');
A = B(200:205,200:205,:) > 160;
B = B(200:215,200:215,:) > 160;
t = ImageProcessor.EXTRA.DILATION(B,A);
imshow(t);
elapsedTime = toc;
disp(elapsedTime);
disp("Size of input image: " + strjoin(arrayfun(@num2str, size(B), 'UniformOutput', false), ' '));
disp("Size of output image: " + strjoin(arrayfun(@num2str, size(t), 'UniformOutput', false), ' '));
\end{verbatim}
\item
  Run the code:
  \includegraphics{images/figure29}\\
\item
  \textbf{Fun fact}: No matter how you twist your input image, if it has
  enough entries that have value \texttt{1}, it will turn into the
  oval-like form with two pointed ends.

  \begin{itemize}
  \tightlist
  \item
    Note: I used \texttt{matrixDecomposition} here for demonstration.
    \texttt{EXTRA.DILATION} also works with 2D binary matrices.
  \item
    Example:\\
    \includegraphics{images/figure30}\\
    As I increase the number of ones:\\
    \includegraphics{images/figure31}
  \end{itemize}
\end{itemize}

\subsection{EXTRA.DILATIONSET and dilationSet Functions with Added
Customized
Functions}\label{extra.dilationset-and-dilationset-functions-with-added-customized-functions}

\subsubsection{\texorpdfstring{1.
\textbf{\texttt{matrixToCoords(A)}}}{1. matrixToCoords(A)}}\label{matrixtocoordsa}

\begin{itemize}
\item
  \textbf{Purpose}: This function converts a matrix (like \texttt{A})
  into a set of coordinates where the value is \texttt{1}.
\item
  \textbf{How it works}: The function scans through the matrix,
  identifying positions with \texttt{1}s, and stores these positions as
  coordinates in a 2D array.
\item
  \textbf{Example}:

\begin{verbatim}
     A = [
       1 1 0 0;
       0 1 0 1
     ];
     coords = ImageProcessor.matrixToCoords(A);
     disp(coords);
     ```
Output:
\end{verbatim}

\begin{verbatim}
 >> 
 0     0
 0     1
 1     1
 1     3
 ```
\end{verbatim}
\end{itemize}

\subsubsection{\texorpdfstring{2.
\textbf{\texttt{coordsToMatrix(B)}}}{2. coordsToMatrix(B)}}\label{coordstomatrixb}

\begin{itemize}
\item
  \textbf{Purpose}: Takes a set of coordinates (like those generated by
  \texttt{matrixToCoords}) and converts them back into a binary matrix
  where \texttt{1}s are placed at the corresponding positions.
\item
  \textbf{How it works}: It initializes a zero matrix of the appropriate
  size, then iterates over the list of coordinates, placing \texttt{1}s
  at each position.
\item
  \textbf{Example}:

\begin{verbatim}
     C = [0 0; 0 1; 1 1; 1 3];
     matrix = ImageProcessor.coordsToMatrix(C);
     disp(matrix);
     ```
Output:
\end{verbatim}

\begin{verbatim}
 >> 
 1     1     0     0
 0     1     0     1
 ```
\end{verbatim}
\end{itemize}

\subsubsection{\texorpdfstring{3.
\textbf{\texttt{dilationSet(A,\ B)}}}{3. dilationSet(A, B)}}\label{dilationseta-b}

\begin{itemize}
\item
  \textbf{Purpose}: Performs the dilation operation between two sets,
  \texttt{A} and \texttt{B}. It calculates the set
  \texttt{$A\ \oplus\ B\ =\ \{\ (a,b)\ +\ (c,d)\ \textbar{}\ (a,b)\ \in\ A,\ (c,d)\ \in\ B\ \}$},
  adding every element of \texttt{B} to every element of \texttt{A}.
\item
  \textbf{How it works}: The function expands both sets using
  \texttt{ndgrid}, then adds their coordinates to create a new set of
  dilated coordinates.
\item
  \textbf{Example}:

\begin{verbatim}
     A = [0 0; 0 1; 1 1; 1 3];  % Example set A
     B = [0 0; 0 1; 1 0];       % Example set B
     C = ImageProcessor.dilationSet(A, B);
     disp(C);
     ```
Output:
\end{verbatim}

\begin{verbatim}
 >> 
 0     0
 0     1
 0     2
 1     0
 1     1
 1     2
 1     3
 1     4
 2     1
 2     3
 ```
\end{verbatim}
\end{itemize}

\subsubsection{\texorpdfstring{\texttt{EXTRA.DILATIONSET} Function and
its Comparison to
\texttt{EXTRA.DILATION}}{EXTRA.DILATIONSET Function and its Comparison to EXTRA.DILATION}}\label{extra.dilationset-function-and-its-comparison-to-extra.dilation}

The function \texttt{EXTRA.DILATIONSET} operates in a way that is
conceptually similar to the function \texttt{EXTRA.DILATION}. Both of
these functions can be considered \textbf{homomorphic} (set that has
negative coordinates can't be converted into matrix), meaning they
perform a similar dilation operation, but on different data structures.
The same concept applies to the relationship between
\texttt{dilationSet} and the \textbf{standard dilation on matrices}.

\begin{itemize}
\tightlist
\item
  \textbf{Important Note}: Unlike \texttt{EXTRA.DILATION}, which is
  designed to handle dilation on matrices of various dimensions,
  \textbf{\texttt{EXTRA.DILATIONSET}} is specifically optimized for
  working with 2D logical matrices in the \textbf{set form} (where
  elements are either \texttt{0} or \texttt{1} in matrix form are
  converted into set of coordinates).
\end{itemize}

\subsubsection{Test Flow}\label{test-flow}

This process ensures that the dilation operation is applied correctly,
and the final result is returned as a matrix. The output is a new
logical matrix that represents the dilation of the specially transformed
input sets.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \textbf{Define the sets \texttt{A} and \texttt{B}} as matrices.
\item
  \textbf{Convert the matrices into coordinates} using
  \texttt{matrixToCoords}.
\item
  \textbf{Perform the dilation operation} between \texttt{A} and
  \texttt{B} using \texttt{EXTRA.DILATIONSET}.
\item
  \textbf{Convert the result back into a matrix} using
  \texttt{coordsToMatrix} and display it.
\end{enumerate}

\begin{verbatim}
A = [
    1 1 0 0;
    0 1 0 1
];

B = [
    0 1;
    1 0
];

disp(ImageProcessor.EXTRA.DILATION(A,B));

A = ImageProcessor.matrixToCoords(A);
B = ImageProcessor.matrixToCoords(B);

C = ImageProcessor.EXTRA.DILATIONSET(A,B);
C = ImageProcessor.coordsToMatrix(C);
disp(C);
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Output:
\end{itemize}

\begin{verbatim}
>> 
     1     1     1     0     0     0     0
     1     1     1     1     1     1     0
     0     1     1     1     1     1     1
     0     0     0     0     1     1     1

     1     1     1     0     0     0     0
     1     1     1     1     1     1     0
     0     1     1     1     1     1     1
     0     0     0     0     1     1     1
\end{verbatim}

\subsubsection{Summary:}\label{summary}

\begin{itemize}
\tightlist
\item
  \texttt{EXTRA.DILATIONSET} = Works similarly to
  \texttt{EXTRA.DILATION}.
\item
  \texttt{EXTRA.DILATIONSET} is \textbf{not suitable} for RGB images or
  matrices with multiple channels so you may have to manually separate
  the channels to calculate it.
\item
  Both \texttt{EXTRA.DILATION} and \texttt{EXTRA.DILATIONSET} can be
  considered \textbf{homomorphic} in their operation.
\end{itemize}

\subsection{ASf(A, d, ind)}\label{asfa-d-ind}

\begin{itemize}
\item
  Input:

  \begin{itemize}
  \tightlist
  \item
    A (required): A 2D numerical matrix containing logical, integer, or
    decimal values.\\
  \item
    d (required): An integer representing the number of times the
    derivative is computed.\\
  \item
    ind (required): An integer representing the column or the columns of
    A to differentiate. Only that column is differentiated while the
    others remain unchanged.
  \end{itemize}
\item
  Output:

  \begin{itemize}
  \tightlist
  \item
    Jacobian (a 2D matrix): A 2D matrix representing the derivatives of
    \texttt{A} after \texttt{d} differentiations.
  \end{itemize}
\item
  Explanation: The \texttt{ASf} function computes the derivative of a
  matrix \textbf{A} a specified number of times (\texttt{d}). If an
  optional column index (\texttt{ind}) is provided, only that column is
  differentiated. Consider the polynomial: $P(x, y) = 3x + 5y + 5x^2 + 4y^2
  + x^3 + 4x^4$

  The coefficients of \textbf{x} and \textbf{y} are stored in a matrix
  form:

  \begin{itemize}
  \tightlist
  \item
    The vector of \textbf{x-coefficients}: ${[}3, 5, 1, 4{]}^T$ → MATLAB
    notation: \texttt{{[}3;\ 5;\ 1;\ 4{]}}
  \item
    The vector of \textbf{y-coefficients}: ${[}5, 4, 0, 0{]}^T$ → MATLAB
    notation: \texttt{{[}5;\ 4;\ 0;\ 0{]}}
  \end{itemize}

  Thus, the \textbf{input matrix} \texttt{A} is:

\begin{verbatim}
[
  3 5;
  5 4;
  1 0;
  4 0
];
\end{verbatim}
\item
  Example code:

\begin{verbatim}
A = [
  3 5;
  5 4;
  1 1;
  4 0
];
disp(ImageProcessor.ASf(A,2,1));
\end{verbatim}

  \begin{itemize}
  \item
    Run the Code:

\begin{verbatim}
>> 
   6     5
  48     4
   0     1
\end{verbatim}

    This result means that after two derivative operations, the only
    nonzero entry comes from the x-column, corresponding to the
    \texttt{$6x\ +\ 48x^2$} term. The y-column stays the same, as expected.
  \end{itemize}
\item
  \textbf{NOTICE:} The input matrix A should \textbf{not} contain any
  constant values from the polynomial. As a result, the output will also
  ignore any constant values after differentiation. \#\#\#
  \textbf{PURPOSES} The \texttt{ASf} function was developed to observe
  \textbf{patterns in an image after differentiation}. Below is an
  example of how to use it for \textbf{image processing}:

\begin{verbatim}
A = [
  1 1 0 0 1 1 0 0 1 1 0 0;
  0 1 0 1 0 1 0 1 0 1 0 1;
  1 1 0 0 1 1 0 0 1 1 0 0;
];
A = ImageProcessor.matrixToCoords(A);
A = ImageProcessor.ASf(A,2,1);
A = ImageProcessor.coordsToMatrix(A);
B = ones([3 3]);
imshow(ImageProcessor.Dilation1(A,B)); % Apply dilation to enhance visualization
\end{verbatim}
\item
  Run the code:\\
  \includegraphics{images/figure32}
\end{itemize}

\subsection{AJF(A, d, ind)}\label{ajfa-d-ind}

\begin{itemize}
\item
  Input:

  \begin{itemize}
  \tightlist
  \item
    A (required): A 2D numerical matrix containing logical, integer, or
    decimal values.\\
  \item
    d (required): An integer representing the number of times the
    derivative is computed.\\
  \item
    ind (optional): An integer (either 1 or 2). \texttt{1} indicates the
    function keeps \textbf{all} columns' positions the same. In the case
    of number \texttt{2}, columns' positions are reversed.
  \end{itemize}
\item
  Output:

  \begin{itemize}
  \tightlist
  \item
    Jacobian (a 2D matrix): A 2D matrix representing the derivatives of
    \texttt{A} after \texttt{d} differentiations.
  \end{itemize}
\item
  Explanation: The \texttt{AJF} function computes the derivative of a
  matrix \textbf{A} a specified number of times (\texttt{d}). It has
  similar inputs like \texttt{ASf} function.
\item
  Example code:

\begin{verbatim}
A = [
  3 5;
  5 4;
  1 0;
  4 0
];
disp(ImageProcessor.AJF(A,2,1));
\end{verbatim}
\item
  Run the code:

\begin{verbatim}
>> 
   6     0
  48     0
\end{verbatim}
\item
  Another example code:

\begin{verbatim}
A = [
  3 5;
  5 4;
  1 1;
  4 0
];
disp(ImageProcessor.AJF(A,2,2));
\end{verbatim}
\item
  Run the Code:

\begin{verbatim}
>> 
 6     6
 0    48
\end{verbatim}
\item
  \textbf{NOTICE:} The input matrix A should \textbf{not} contain any
  constant values from the polynomial. As a result, the output will also
  ignore any constant values after differentiation.
\item
  Another example code:

\begin{verbatim}
A = [
  1 1 0 0 1 1 0 0 1 1 0 0;
  0 1 0 1 0 1 0 1 0 1 0 1;
  1 1 0 0 1 1 0 0 1 1 0 0;
];
A = ImageProcessor.matrixToCoords(A);
A = ImageProcessor.AJF(A,2,1);
A = ImageProcessor.coordsToMatrix(A);
B = ones([8 8]);
imshow(ImageProcessor.Dilation1(A,B)); % Apply dilation to enhance visualization
\end{verbatim}
\item
  Run the code:\\
  \includegraphics{images/figure33}
\end{itemize}

\subsection{PDilation(A, B) \&
reversedPDilation(Cs)}\label{pdilationa-b-reversedpdilationcs}

\subsubsection{Summary of PDilation}\label{summary-of-pdilation}

This is a custom convolution-like operation on 1D integer arrays A and
B, defined as:

\begin{verbatim}
dilatedPartition = ImageProcessor.M2P(ImageProcessor.Dilation1(ImageProcessor.P2M(A),ImageProcessor.P2M(B)));
\end{verbatim}

Where \texttt{M2P} convert matrix into partition and \texttt{P2M}
performs otherwise. The code section of \texttt{PDilation} can be
re-defined as:

\begin{verbatim}
C = flip(partitionA - 1) + partitionB';
... % Some exceptions handling
\end{verbatim}

Then the result dilatedPartition is formed by: - Sliding across
diagonals of \texttt{C}\\
- Taking the maximum from each diagonal

This is like a max-plus convolution (like plus-multiplication
\texttt{conv} from MATLAB), which appears in scheduling theory, image
dilation, and mathematical morphology.\\
There will be a separate
\href{https://github.com/zedttxj/Image-Processing-Tool-with-Matlab/blob/main/optional/PDilation-reversedPDilation.md}{explanation}
as why is it (PDilation) defined this way. I would love to explain some
theories like why divide-and-conquer may not be applicable in the case
of \texttt{reversedPDilation} as well as show some properties. \#\#\#\#
Important Properties \textbf{\emph{Commutative?}}\\
Yes, because \texttt{flip(A\ -\ 1)\ +\ B\textquotesingle{}} is symmetric
in A and B, up to flipping; and, max of diagonals doesn't depend on
which array came first.\\
\textbf{\emph{Associative?}}\\
Also a yes because of how flipping, addition, and max behave. \#\#\#
PDilation(A, B) - Input: - partitionA (required): non-increasing 1D
non-negative integer vector - partitionB (required): non-increasing 1D
non-negative integer vector\\
- Output: - dilatedPartition (1D integer vector): A 1D non-increasing
non-negative integer vector - Example code:
\texttt{matlab\ \ \ A\ =\ {[}5\ 4\ 3\ 2{]};\ \ \ B\ =\ {[}7\ 3\ 1{]};\ \ \ C\ =\ ImageProcessor.PDilation(A,B);\ \ \ disp(C);}
- Run the code:
\texttt{\textgreater{}\textgreater{}\ \ \ \ \ \ 11\ \ \ \ 10\ \ \ \ \ 9\ \ \ \ \ 8\ \ \ \ \ 4\ \ \ \ \ 2}
\#\#\# reversedPDilation(A, B) - Input: - Cs (required): A
non-increasing, one-dimensional vector of non-negative integers\\
- Output: - dilatedPartition (1D integer vector): A 2D cell array
containing pairs of partitions, where \texttt{size(dilatedPartition)}
would be
\texttt{{[}\textless{}number\ of\ partitions\textgreater{}\ 2{]}}. -
Explanation: \texttt{reversedPDilation} generates all possible pairs of
partitions such that applying \texttt{PDilation} to them results in
\texttt{Cs}. - Example code:
\texttt{matlab\ \ \ C\ =\ ImageProcessor.reversedPDilation({[}11\ \ \ \ 10\ \ \ \ \ 9\ \ \ \ \ 8\ \ \ \ \ 4\ \ \ \ \ 2{]});\ \ \ disp(C);\ \ \ disp(size(C));}
- Run the code: ``` \textgreater\textgreater{} \{{[} 1{]}\} \{{[}11 10 9
8 4 2{]}\} \{{[} 2{]}\} \{{[} 10 9 8 7 3 1{]}\} \{{[} 2 1{]}\} \{{[} 10
8 8 4 2{]}\} \{{[} 2 1{]}\} \{{[} 10 9 8 4 2{]}\} \{{[} 3 2{]}\} \{{[} 9
7 7 3 1{]}\} \{{[} 3 2{]}\} \{{[} 9 8 7 3 1{]}\} \{{[} 3 1 1{]}\} \{{[}
9 8 4 2{]}\} \{{[} 3 2 1{]}\} \{{[} 9 8 4 2{]}\} \{{[} 4 2 2{]}\} \{{[}
8 7 3 1{]}\} \{{[} 4 3 2{]}\} \{{[} 8 7 3 1{]}\} \{{[} 7 3 1{]}\} \{{[}
5 4 3 2{]}\} \{{[} 8 4 2{]}\} \{{[} 4 3 2 1{]}\} \{{[} 4 3 2 1{]}\}
\{{[} 8 4 2{]}\} \{{[} 5 4 3 2{]}\} \{{[} 7 3 1{]}\} \{{[} 8 7 3 1{]}\}
\{{[} 4 2 2{]}\} \{{[} 8 7 3 1{]}\} \{{[} 4 3 2{]}\} \{{[} 9 8 4 2{]}\}
\{{[} 3 1 1{]}\} \{{[} 9 8 4 2{]}\} \{{[} 3 2 1{]}\} \{{[} 9 7 7 3
1{]}\} \{{[} 3 2{]}\} \{{[} 9 8 7 3 1{]}\} \{{[} 3 2{]}\} \{{[} 10 8 8 4
2{]}\} \{{[} 2 1{]}\} \{{[} 10 9 8 4 2{]}\} \{{[} 2 1{]}\} \{{[} 10 9 8
7 3 1{]}\} \{{[} 2{]}\} \{{[}11 10 9 8 4 2{]}\} \{{[} 1{]}\}

\begin{verbatim}
24     2
\end{verbatim}

```

\subsubsection{Relation to Tropical Polynomial
Product}\label{relation-to-tropical-polynomial-product}

Given two tropical polynomials:

\texttt{$f(x)\ =\ \mu_{1}\otimes x^0\oplus\mu_{2}\otimes x^1\oplus\mu_{3}\otimes x^2\oplus\mu_{4}\otimes x^3$}
\texttt{$g(x)\ =\ \nu_{1}\otimes x^0\oplus\nu_{2}\otimes x^1\oplus\nu_{3}\otimes x^2$}

Their tropical product is defined as:

\texttt{$f(x)\ \odot\ g(x)\ =\ (\mu_{1}\otimes\nu_{1})\otimes x^0\oplus(\mu_{2}\otimes\nu_{1}\oplus\mu_{1}\otimes\nu_{2})\otimes x^1\oplus(\mu_{3}\otimes\nu_{1}\oplus\mu_{2}\otimes\nu_{2}\oplus\mu_{1}\otimes\nu_{3})\otimes x^2\oplus(\mu_{3}\otimes\nu_{2}\oplus\mu_{2}\otimes\nu_{3}\oplus\mu_{1}\otimes\nu_{4})\otimes x^3\oplus(\mu_{3}\otimes\nu_{3}\oplus\mu_{2}\otimes\nu_{4})\otimes x^4\oplus(\mu_{3}\otimes\nu_{4})\otimes x^5$}

Or:

\texttt{$f(x)\ \odot\ g(x)\ =\ max(max(\mu_{1}+\nu_{1})+0x,max(\mu_{2}+\nu_{1},\mu_{1}+\nu_{2})+1x,max(\mu_{3}+\nu_{1},\mu_{2}+\nu_{2},\mu_{1}+\nu_{3})+2x,max(\mu_{3}+\nu_{2},\mu_{2}+\nu_{3},\mu_{1}+\nu_{4})+3x,max(\mu_{3}+\nu_{3},\mu_{2}+\nu_{4})+4x,max(\mu_{3}+\nu_{4})+5x)$}

\textbf{Notice} that the PDilation has all of its values substracted by
1. PDilation is not exactly tropical multiplication of the raw
polynomial terms: \#\#\#\# Example: Let:\\
- $\lambda = (7, 4, 3, 2)$\\
- $\lambda^\prime = (5, 3, 1)$

Then:\\
- \texttt{$PDilation(\lambda,\ \lambda^\prime)\ =\ (11,\ 10,\ 9,\ 8,\ 4,\ 2)$}
- \texttt{$f_{(7,4,3,2)} \odot f_{(5,3,1)}\ =\ f_{(12,11,10,9,5,3)}$}

We can conclude that
\texttt{$f_{\lambda}\ \odot\ f_{\lambda^\prime}\ =\ f_{PDilation(\lambda,\ \lambda^\prime)\ +\ 1}$}










\vspace{.4cm}

\vspace*{3mm} 
\begin{flushright}
\begin{minipage}{148mm}\sc\footnotesize
	
	Adnan Hashim Abdulwahid\\
	College of Business, Engineering, and Technology \\
	Texas A$\&$M University--Texarkana\\
	7101 University Ave, Texarkana, TX, 75503,  USA
	
	{\tt \begin{tabular}{lllll}
			{\it E--mail address} :	&  {\color{blue}
				AAbdulwahid@tamut.edu}\\
			&  {\color{blue} adnanalgebra@gmail.com}\\
	\end{tabular} }\vspace*{3mm}
	
	\vspace{.2cm}
\end{minipage}
\end{flushright}









\begin{thebibliography}{5}
\bibitem{Adnan1} Adnan H. Abdulwahid and Elgaddafi Elamami. Bayer Noise Symmetric Functions and
Some Combinatorial Algebraic Structures. JMA (2023)  Volume 46, Pages 115-148. Available Online  \url{https://journals.prz.edu.pl/jma/article/view/1527/1146}.

\bibitem{Adnan2} Adnan H. Abdulwahid. Bayer Noise Quasisymmetric Functions and Some Combinatorial Algebraic Structures. CGASA (2024). Volume 21, Issue 1. Available Online 
\url{https://cgasa.sbu.ac.ir/article_104669_b2dd38f31d3918c0ee50708ef4570204.pdf}. 	

\bibitem{Andrews} George E. Andrews. The Theory of Partitions. Cambridge, England: Cambridge University Press, 1998.

\bibitem{Dawsey} Madeline Locus Dawsey, Tyler Russell, and Dannie Urban. Derivatives and Integrals of Polynomials Associated
with Integer Partitions. {\bf 2022}.
\url{https://browse.arxiv.org/pdf/2108.00943.pdf}


\bibitem{Grinberg} Darij Grinberg. Victor Reiner. Hopf algebras in combinatorics. {\it Lecture notes, Vrije Universiteit Brussel} {\bf 2020}.
\url{https://www.cip.ifi.lmu.de/~grinberg/algebra/HopfComb.pdf}

\bibitem{Macdonald}
Ian Grant Macdonald.
Symmetric functions and Hall polynomials.
2nd edition, Oxford University Press, Oxford-New York, 1995.

\bibitem{Meliot} 
Pierre-Lo\"ic M\'eliot.
Representation Theory
of Symmetric Groups,
{\it Discrete Mathematics and its Applications},
CRC Press 2017.

\bibitem{Mendes}
Anthony Mendes, Jeffrey Remmel,
Counting with Symmetric Functions.
{\it Developments in Mathematics} {\bf 43},
Springer 2015.


\bibitem{Sagan} Bruce E. Sagan.
Combinatorics: The Art of Counting.
Draft of a textbook, 2020.
\url{https://users.math.msu.edu/users/bsagan/Books/Aoc/aoc.pdf}.

\bibitem{Sam-symf}
Steven V. Sam,
Notes for Math 740 (Symmetric Functions),
27 April 2017.
\url{https://www.math.wisc.edu/~svs/740/notes.pdf}

\bibitem{Stanley}
Richard P. Stanley. 
Enumerative Combinatorics, Volumes 1 and 2.
{\it Cambridge Studies in Advanced Mathematics}, {\bf 49} and {\bf 62}.
Cambridge University Press, Cambridge, 2nd edition 2011 (volume 1)
and 1st edition 1999 (volume 2).

\bibitem{Wildon2016} Mark Wildon. An involutive introduction to symmetric functions. 1 July 2017. \url{http://www.ma.rhul.ac.uk/~uvah099/teaching.html}






\end{thebibliography}  

\end{document}
